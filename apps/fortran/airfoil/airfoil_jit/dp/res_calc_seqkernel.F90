!
! auto-generated by op2.py
!

MODULE RES_CALC_MODULE
USE OP2_FORTRAN_DECLARATIONS
USE OP2_FORTRAN_RT_SUPPORT
USE ISO_C_BINDING
USE OP2_CONSTANTS

CONTAINS

SUBROUTINE res_calc_host( userSubroutine, set, &
  & opArg1, &
  & opArg2, &
  & opArg3, &
  & opArg4, &
  & opArg5, &
  & opArg6, &
  & opArg7, &
  & opArg8 )

  IMPLICIT NONE
  character(kind=c_char,len=*), INTENT(IN) :: userSubroutine
  type ( op_set ) , INTENT(IN) :: set

  type ( op_arg ) , INTENT(IN) :: opArg1
  type ( op_arg ) , INTENT(IN) :: opArg2
  type ( op_arg ) , INTENT(IN) :: opArg3
  type ( op_arg ) , INTENT(IN) :: opArg4
  type ( op_arg ) , INTENT(IN) :: opArg5
  type ( op_arg ) , INTENT(IN) :: opArg6
  type ( op_arg ) , INTENT(IN) :: opArg7
  type ( op_arg ) , INTENT(IN) :: opArg8

  integer STATUS

  integer(c_int), parameter :: rtld_lazy=1 ! value extracte from the C header file
  integer(c_int), parameter :: rtld_now=2 ! value extracte from the C header file

  !
  ! interface to linux API
  interface
      function dlopen(filename,mode) bind(c,name="dlopen")
          ! void *dlopen(const char *filename, int mode);
          use iso_c_binding
          implicit none
          type(c_ptr) :: dlopen
          character(c_char), intent(in) :: filename(*)
          integer(c_int), value :: mode
      end function

      function dlsym(handle,name) bind(c,name="dlsym")
          ! void *dlsym(void *handle, const char *name);
          use iso_c_binding
          implicit none
          type(c_funptr) :: dlsym
          type(c_ptr), value :: handle
          character(c_char), intent(in) :: name(*)
      end function

      function dlclose(handle) bind(c,name="dlclose")
          ! int dlclose(void *handle);
          use iso_c_binding
          implicit none
          integer(c_int) :: dlclose
          type(c_ptr), value :: handle
      end function
  end interface

  ! Define interface of call-back routine.
  abstract interface
      subroutine called_proc (userSubroutine, set, &
    & opArg1, &
    & opArg2, &
    & opArg3, &
    & opArg4, &
    & opArg5, &
    & opArg6, &
    & opArg7, &
    & opArg8 ) bind(c)

      use, intrinsic :: iso_c_binding
      USE OP2_FORTRAN_DECLARATIONS
      USE OP2_FORTRAN_RT_SUPPORT
      USE OP2_CONSTANTS

      !character(kind=c_char,len=*), INTENT(IN) :: userSubroutine
      character(kind=c_char), dimension(*), intent(in) :: userSubroutine
      type ( op_set ) , INTENT(IN) :: set

      type ( op_arg ) , INTENT(IN) :: opArg1
      type ( op_arg ) , INTENT(IN) :: opArg2
      type ( op_arg ) , INTENT(IN) :: opArg3
      type ( op_arg ) , INTENT(IN) :: opArg4
      type ( op_arg ) , INTENT(IN) :: opArg5
      type ( op_arg ) , INTENT(IN) :: opArg6
      type ( op_arg ) , INTENT(IN) :: opArg7
      type ( op_arg ) , INTENT(IN) :: opArg8

      end subroutine called_proc
  end interface
  ! End interface of call-back routine

  type(c_funptr) :: proc_addr
  type(c_ptr) :: handle
  procedure(called_proc), bind(c), pointer :: proc

  ! compile res_calc_seqkernel_rec.F90 using system command
  write(*,*) 'JIT compiling procedure res_calc_host_rec'
  call execute_command_line ("make -j res_calc_jit", exitstat=STATUS)

  ! dynamically load res_calc_host_rec.so
  handle=dlopen("./res_calc_seqkernel_rec.so"//c_null_char, RTLD_LAZY)
  if (.not. c_associated(handle))then
      print*, 'Unable to load DLL ./res_calc_seqkernel_rec.so'
      stop
  end if
  !
  proc_addr=dlsym(handle, "res_calc_module_execute_mp_res_calc_host_rec_"//c_null_char)
  if (.not. c_associated(proc_addr))then
      write(*,*) 'Unable to load the procedure res_calc_module_execute_mp_res_calc_host_rec_'
      stop
  end if



  ! call/execute dynamically loaded procedure with the parameters from res_calc_host() signature
  call c_f_procpointer( proc_addr, proc )
  call proc( userSubroutine, set, &
  & opArg1, &
  & opArg2, &
  & opArg3, &
  & opArg4, &
  & opArg5, &
  & opArg6, &
  & opArg7, &
  & opArg8 )

END SUBROUTINE
END MODULE
