!
! auto-generated by op2.py
!

MODULE RES_CALC_MODULE
USE OP2_FORTRAN_DECLARATIONS
USE OP2_FORTRAN_RT_SUPPORT
USE OP2_FORTRAN_JIT
USE OP2_CONSTANTS
USE ISO_C_BINDING


type(c_funptr) :: proc_addr_res_calc

CONTAINS

SUBROUTINE res_calc_host( userSubroutine, set, &
  & opArg1, &
  & opArg2, &
  & opArg3, &
  & opArg4, &
  & opArg5, &
  & opArg6, &
  & opArg7, &
  & opArg8 )

  IMPLICIT NONE
  character(kind=c_char,len=*), INTENT(IN) :: userSubroutine
  type ( op_set ) , INTENT(IN) :: set

  type ( op_arg ) , INTENT(IN) :: opArg1
  type ( op_arg ) , INTENT(IN) :: opArg2
  type ( op_arg ) , INTENT(IN) :: opArg3
  type ( op_arg ) , INTENT(IN) :: opArg4
  type ( op_arg ) , INTENT(IN) :: opArg5
  type ( op_arg ) , INTENT(IN) :: opArg6
  type ( op_arg ) , INTENT(IN) :: opArg7
  type ( op_arg ) , INTENT(IN) :: opArg8

  integer STATUS

  integer(c_int), parameter :: RTLD_LAZY=1 ! value extracte from the C header file

  ! Define interface of call-back routine.
  abstract interface
      subroutine called_proc (userSubroutine, set, &
    & opArg1, &
    & opArg2, &
    & opArg3, &
    & opArg4, &
    & opArg5, &
    & opArg6, &
    & opArg7, &
    & opArg8 ) bind(c)

      use, intrinsic :: iso_c_binding
      USE OP2_FORTRAN_DECLARATIONS
      USE OP2_FORTRAN_RT_SUPPORT
      USE OP2_CONSTANTS

      !character(kind=c_char,len=*), INTENT(IN) :: userSubroutine
      character(kind=c_char), dimension(*), intent(in) :: userSubroutine
      type ( op_set ) , INTENT(IN) :: set

      type ( op_arg ) , INTENT(IN) :: opArg1
      type ( op_arg ) , INTENT(IN) :: opArg2
      type ( op_arg ) , INTENT(IN) :: opArg3
      type ( op_arg ) , INTENT(IN) :: opArg4
      type ( op_arg ) , INTENT(IN) :: opArg5
      type ( op_arg ) , INTENT(IN) :: opArg6
      type ( op_arg ) , INTENT(IN) :: opArg7
      type ( op_arg ) , INTENT(IN) :: opArg8

      end subroutine called_proc
  end interface
  ! End interface of call-back routine

  procedure(called_proc), bind(c), pointer :: proc_res_calc
  type(c_ptr) :: handle

  if(.not. c_associated(proc_addr_res_calc)) then

    ! compile res_calc_seqkernel_rec.F90 using system command
    write(*,*) 'JIT compiling procedure res_calc_host_rec'
    call execute_command_line ("make -j res_calc_jit", exitstat=STATUS)

    ! dynamically load res_calc_host_rec.so
    handle=dlopen("./res_calc_seqkernel_rec.so"//c_null_char, RTLD_LAZY)
    if (.not. c_associated(handle))then
        print*, 'Unable to load DLL ./res_calc_seqkernel_rec.so'
        stop
    end if

    proc_addr_res_calc=dlsym(handle, "res_calc_module_execute_mp_res_calc_host_rec_"//c_null_char)
    if (.not. c_associated(proc_addr_res_calc))then
        write(*,*) 'Unable to load the procedure res_calc_module_execute_mp_res_calc_host_rec_'
        stop
    end if
    call c_f_procpointer( proc_addr_res_calc, proc_res_calc )

  end if

  ! call/execute dynamically loaded procedure with the parameters from res_calc_host() signature
  call proc_res_calc( userSubroutine, set, &
  & opArg1, &
  & opArg2, &
  & opArg3, &
  & opArg4, &
  & opArg5, &
  & opArg6, &
  & opArg7, &
  & opArg8 )

END SUBROUTINE
END MODULE
