//
// auto-generated by op2.py
//

// header
#include "op_lib_cpp.h"
#include "op_cuda_rt_support.h"
#include "op_cuda_reduction.h"

// global constants
__constant__ double gam_cuda;
__constant__ double gm1_cuda;
__constant__ double cfl_cuda;
__constant__ double eps_cuda;
__constant__ double mach_cuda;
__constant__ double alpha_cuda;
extern __shared__ double qinf_cuda[4];

#ifndef OP2_JIT

void op_decl_const_char(int dim, char const *type,
                        int size, char *dat,
                        char const *name)
{
  // copy value to device constant
  if (!strcmp(name,"gam")) {
    cutilSafeCall(cudaMemcpyToSymbol(gam_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"gm1")) {
    cutilSafeCall(cudaMemcpyToSymbol(gm1_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"cfl")) {
    cutilSafeCall(cudaMemcpyToSymbol(cfl_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"eps")) {
    cutilSafeCall(cudaMemcpyToSymbol(eps_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"mach")) {
    cutilSafeCall(cudaMemcpyToSymbol(mach_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"alpha")) {
    cutilSafeCall(cudaMemcpyToSymbol(alpha_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"qinf")) {
    cutilSafeCall(cudaMemcpyToSymbol(qinf_cuda, dat, dim*size));
  }
  else
  {
    printf("error: unknown const name\n");
    exit(1);
  }
}

#else

void op_decl_const_char(int dim, char const *type,
                        int size, char *dat,
                        char const *name)
{
  if (dim == 1) {
    op_lazy_const(dim, type, size, dat, name);
  }
  else {
    for (int d = 0; d < dim; ++d)
    {
      char name2[32];
      sprintf(name2, "op_const_%s_%d\0", name, d);
      printf("%s|\n", name2);
      op_lazy_const(1, type, size, dat+(d*size), name2);
    }
  }
}

// pointers to recompiled functions
void (*save_soln_function)(struct op_kernel_descriptor *desc) = NULL;
void (*adt_calc_function)(struct op_kernel_descriptor *desc) = NULL;
void (*res_calc_function)(struct op_kernel_descriptor *desc) = NULL;
void (*bres_calc_function)(struct op_kernel_descriptor *desc) = NULL;
void (*update_function)(struct op_kernel_descriptor *desc) = NULL;

void jit_compile() {
  op_printf("JIT compiling op_par_loops\n");

  //Write constants to header file
  if (op_is_root()) {
    int ret = system("make -j airfoil_cuda_jit");
  }
  op_mpi_barrier();
  void *handle;
  char *error;

  //create .so
  handle = dlopen("cuda/airfoil_kernel_rec.so", RTLD_LAZY);
  if (!handle) {
    fputs(dlerror(), stderr);
    exit(1);
  }

  //dynamically load functions from the  .so
  save_soln_function = (void (*)(op_kernel_descriptor *))dlsym(
    handle, "op_par_loop_save_soln_rec_execute");
  if ((error = dlerror()) != NULL) {
    fputs(error, stderr);
    exit(1);
  }
  adt_calc_function = (void (*)(op_kernel_descriptor *))dlsym(
    handle, "op_par_loop_adt_calc_rec_execute");
  if ((error = dlerror()) != NULL) {
    fputs(error, stderr);
    exit(1);
  }
  res_calc_function = (void (*)(op_kernel_descriptor *))dlsym(
    handle, "op_par_loop_res_calc_rec_execute");
  if ((error = dlerror()) != NULL) {
    fputs(error, stderr);
    exit(1);
  }
  bres_calc_function = (void (*)(op_kernel_descriptor *))dlsym(
    handle, "op_par_loop_bres_calc_rec_execute");
  if ((error = dlerror()) != NULL) {
    fputs(error, stderr);
    exit(1);
  }
  update_function = (void (*)(op_kernel_descriptor *))dlsym(
    handle, "op_par_loop_update_rec_execute");
  if ((error = dlerror()) != NULL) {
    fputs(error, stderr);
    exit(1);
  }
  op_mpi_barrier();
  jit_compiled = 1;
}

#endif
// user kernel files
#include "save_soln_kernel.cu"
#include "adt_calc_kernel.cu"
#include "res_calc_kernel.cu"
#include "bres_calc_kernel.cu"
#include "update_kernel.cu"
